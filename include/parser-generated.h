/*
 * This file was generated by build_grammar.py, DO NOT MODIFY!
 */
#pragma once

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

#include "type.h"
#include "dynstring.h"

// order of these two enums is crucial
typedef enum
{
    NT_IDENTIFIER_LIST_WITH_TYPES2,
    NT_FOR_LOOP,
    NT_OPTIONAL_FOR_STEP,
    NT_EXPRESSION,
    NT_TYPE_LIST,
    NT_FUNC_DECL,
    NT_GLOBAL_STATEMENT_LIST,
    NT_ASSIGNMENT,
    NT_DECLARATION,
    NT_REPEAT_UNTIL,
    NT_IDENTIFIER_LIST2,
    NT_IDENTIFIER_WITH_TYPE,
    NT_WHILE_LOOP,
    NT_OPTIONAL_FUN_EXPRESSION_LIST,
    NT_RETURN_STATEMENT,
    NT_UNOP,
    NT_COND_STATEMENT,
    NT_TERM,
    NT_TYPE_LIST2,
    NT_EXPRESSION_LIST,
    NT_GLOBAL_STATEMENT,
    NT_STATEMENT,
    NT_EXPRESSION_LIST2,
    NT_PROGRAM,
    NT_OPT_BINOP,
    NT_IDENTIFIER_LIST,
    NT_FUNC_DEF,
    NT_FUNC_TYPE_LIST2,
    NT_RET_EXPRESSION_LIST2,
    NT_STATEMENT_LIST2,
    NT_BINOP,
    NT_DECL_OPTIONAL_ASSIGNMENT,
    NT_STATEMENT_LIST,
    NT_IDENTIFIER_LIST_WITH_TYPES,
    NT_FUN_EXPRESSION_LIST2,
    NT_RET_EXPRESSION_LIST,
    NT_FUNC_CALL,
    NT_COND_OPT_ELSEIF,
    NT_FUNC_TYPE_LIST,
} nterm_type_t;

typedef enum
{
    T_DOUBLE_DOT,
    T_INTEGER,
    T_LOCAL,
    T_EQUALS,
    T_FOR,
    T_NUMBER,
    T_ASTERISK,
    T_LTE,
    T_REQUIRE,
    T_AND,
    T_STRING,
    T_EXPRESSION,
    T_NOT,
    T_SLASH,
    T_BOOL,
    T_NIL,
    T_FUNCTION,
    T_RPAREN,
    T_IF,
    T_HASH,
    T_ELSEIF,
    T_MINUS,
    T_RETURN,
    T_IDENTIFIER,
    T_TYPE,
    T_UNTIL,
    T_WHILE,
    T_END,
    T_EOF,
    T_COMMA,
    T_GT,
    T_CARET,
    T_DOUBLE_SLASH,
    T_GLOBAL,
    T_PERCENT,
    T_DO,
    T_OR,
    T_THEN,
    T_REPEAT,
    T_DOUBLE_EQUALS,
    T_BREAK,
    T_GTE,
    T_ELSE,
    T_LT,
    T_TILDE_EQUALS,
    T_COLON,
    T_PLUS,
    T_LPAREN,
} term_type_t;

// nterm U term => nut
typedef struct {
    bool is_nterm;
    union {
        nterm_type_t nterm;
        term_type_t term;
    };
} nut_type_t;

typedef struct {
    size_t size;
    nut_type_t *data;
    bool valid;
} exp_list_t;

// hashmap without collisions
typedef struct {
    size_t bucket_count;
    exp_list_t data[];
} parser_table_t;

typedef struct {
    term_type_t token_type;
    union {
        string_t string;
        type_t type;
        int64_t integer;
        double number;
    };
} token_t;

size_t parser_get_table_index(nterm_type_t nterm, term_type_t term);
const char *nterm_to_readable(nterm_type_t nterm);
const char *term_to_readable(term_type_t term);
int parser_init();
void parser_free();

extern parser_table_t *table;
